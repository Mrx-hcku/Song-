<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Song</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* --- ARCHITECTURE MINDSET: CSS Variables & Global Styles --- */
        :root {
            /* Color Palette */
            --primary-accent: #00ff7f; /* Neon Green/Control */
            --secondary-accent: #ff3366; /* Pink/Branding */
            --bg-deep: #0a0a0a; /* Deep Black Background */
            --bg-card: #141414; /* Elevated Card Surface */
            --text-high: #ffffff;
            --text-low: #b3b3b3;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;

            /* UI Elements */
            --border-radius-sm: 4px;
            --border-radius-lg: 10px;
        }

        /* Global Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Poppins', sans-serif;
            -webkit-tap-highlight-color: transparent; 
            touch-action: manipulation;
            -ms-touch-action: pan-x pan-y;
        }
        body {
            background-color: var(--bg-deep);
            color: var(--text-high);
            /* Fixed Scene Lock */
            height: 100vh; 
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            font-weight: 400;
        }

        /* --- APP TITLE ANIMATION --- */
        #appTitle {
            font-size: 1.5rem;
            font-weight: 800;
            text-align: center;
            padding: var(--spacing-md);
            background-color: var(--bg-deep);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* Animation for "Song" */
        .char {
            display: inline-block;
            opacity: 0;
            animation: fadeIn 0.8s forwards;
            animation-delay: calc(0.1s * var(--char-index));
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        #appTitle .char:nth-child(1) { color: var(--primary-accent); } /* S */
        #appTitle .char:nth-child(2) { color: var(--secondary-accent); } /* o */
        #appTitle .char:nth-child(3) { color: var(--primary-accent); } /* n */
        #appTitle .char:nth-child(4) { color: var(--secondary-accent); } /* g */
        
        /* --- NAVIGATION (Bottom Bar Style for Modern Mobile Apps) --- */
        .navigation {
            display: flex;
            justify-content: space-around;
            padding: var(--spacing-sm) 0;
            background-color: var(--bg-card);
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.5);
            position: fixed; 
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 30;
        }
        .nav-item {
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-low);
            transition: color 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .nav-item.active {
            color: var(--primary-accent);
        }
        .nav-item svg {
            width: 22px;
            height: 22px;
            fill: currentColor; 
            margin-bottom: 2px;
        }
        
        /* --- LAYOUT AND SCROLLABLE CONTENT --- */
        .main-container {
            /* Original Height: Total Height - Nav Bar (60px) - Player Bar (approx 145px) - Title Bar (approx 50px) */
            --player-bar-height: 145px; /* Define variable */
            --nav-bar-height: 60px;
            --title-bar-height: 50px;
            height: calc(100vh - var(--nav-bar-height) - var(--player-bar-height) - var(--title-bar-height)); 
            flex-grow: 1;
            overflow-y: auto; 
            padding: 0 var(--spacing-md); /* Removed top padding, title is fixed */
            /* New: Transition for smooth height change */
            transition: height 0.3s ease-out;
        }
        
        /* New: Adjust height when player is minimized (class added to <body>) */
        body.player-minimized .main-container {
            /* Total Height - Nav Bar (60px) - Title Bar (approx 50px) */
            height: calc(100vh - var(--nav-bar-height) - var(--title-bar-height));
        }

        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .heading-module {
            font-size: 1.5rem;
            font-weight: 700;
            margin: var(--spacing-lg) 0 var(--spacing-md);
            border-left: 4px solid var(--secondary-accent);
            padding-left: var(--spacing-sm);
        }
        /* Style for sub-headings within sections */
        .sub-heading-module {
            font-size: 1.2rem;
            font-weight: 600;
            margin: var(--spacing-md) 0 var(--spacing-sm);
            color: var(--primary-accent);
        }

        /* --- SEARCH BAR --- */
        .search-container-top {
            display: flex;
            gap: var(--spacing-sm);
            padding: var(--spacing-md) 0;
            position: sticky; 
            top: 0;
            background-color: var(--bg-deep);
            z-index: 5;
        }
        #searchInput {
            flex-grow: 1;
            padding: 10px var(--spacing-md);
            border-radius: 50px;
            border: none;
            background-color: var(--bg-card);
            color: var(--text-high);
            font-size: 1rem;
            outline: none;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.4);
        }
        
        /* UPDATED: Search Button as Icon */
        .search-button {
            width: 42px; /* Fixed size for icon button */
            height: 42px;
            padding: 0;
            border-radius: 50%;
            border: none;
            background-color: var(--primary-accent);
            color: var(--bg-deep);
            cursor: pointer;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s, background-color 0.2s;
            flex-shrink: 0;
        }
        .search-button:active {
            transform: scale(0.9);
        }
        .search-button svg {
            width: 20px;
            height: 20px;
            fill: var(--bg-deep);
        }
        
        /* NEW: Search Tabs Style */
        .search-tab-container {
            display: flex; 
            justify-content: space-between; 
            padding: var(--spacing-sm) 0; 
            border-bottom: 1px solid var(--bg-card);
            margin-bottom: var(--spacing-md);
        }
        .search-tab {
            background: none;
            border: none;
            color: var(--text-low);
            padding: var(--spacing-xs) var(--spacing-sm);
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: color 0.2s, border-bottom 0.2s;
        }
        .search-tab.active {
            color: var(--primary-accent);
            border-bottom: 2px solid var(--primary-accent);
        }

        /* --- CARD MODULES (Home Grid) --- */
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }
        .card-module {
            background-color: var(--bg-card);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-lg);
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .card-module:hover {
            background-color: #222;
        }
        .card-module img {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: var(--border-radius-sm);
            margin-bottom: var(--spacing-sm);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .card-module strong {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .card-module span {
            font-size: 0.75rem;
            color: var(--text-low);
        }
        
        /* --- TRACK LIST (Search/Queue/Favorites) --- */
        .track-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }
        .track-item {
            display: flex;
            align-items: center;
            padding: var(--spacing-sm);
            background-color: transparent;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            position: relative;
        }
        .track-item:hover {
            background-color: #1a1a1a;
        }
        /* Drag-and-Drop Styles */
        .track-item.dragging {
            opacity: 0.5;
            background-color: #333;
            border: 1px dashed var(--primary-accent);
        }
        .track-item.drag-over-above {
            border-top: 2px solid var(--secondary-accent);
        }
        .track-item.drag-over-below {
            border-bottom: 2px solid var(--secondary-accent);
        }
        
        .track-item.is-playing {
             border-left: 3px solid var(--primary-accent);
             background-color: #1a1a1a;
        }
        .track-item.is-playing .track-info strong {
            color: var(--primary-accent);
        }

        .track-item img {
            width: 40px;
            height: 40px;
            border-radius: var(--border-radius-sm);
            margin-right: var(--spacing-md);
            object-fit: cover;
            flex-shrink: 0;
        }
        .track-info {
            flex-grow: 1;
            overflow: hidden;
        }
        .track-info strong {
            display: block;
            font-size: 0.9em;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-high);
            transition: color 0.2s;
        }
        .track-info span {
            display: block;
            font-size: 0.75em;
            color: var(--text-low);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .track-icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
            margin-left: var(--spacing-sm);
            flex-shrink: 0;
        }
        .loading-state {
            color: var(--text-low);
            text-align: center;
            padding: var(--spacing-lg);
        }
        
        /* NEW: Favorite/Add to Playlist Button Styling */
        .control-list-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            line-height: 0;
            margin-left: var(--spacing-sm);
            flex-shrink: 0;
        }
        .control-list-button svg {
            width: 20px;
            height: 20px;
            fill: var(--text-low);
            transition: fill 0.2s;
        }
        .control-list-button.is-favorite svg {
            fill: var(--secondary-accent); /* Pink color for liked */
        }
        
        /* NEW: Drag Handle for Reordering */
        .drag-handle {
            cursor: move;
            margin-right: var(--spacing-sm);
            opacity: 0.7;
        }
        .drag-handle svg {
            width: 18px;
            height: 18px;
            fill: var(--text-low);
        }
        /* Hide drag handle in search results for cleaner UI */
        #songResults .drag-handle {
            display: none;
        }

        /* --- PLAYLISTS SECTION STYLES --- */
        #createPlaylistButton {
            background-color: var(--primary-accent);
            color: var(--bg-deep);
            border: none;
            padding: 10px 15px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 700;
            display: block;
            width: 100%;
            margin: var(--spacing-md) 0;
            transition: background-color 0.2s;
        }
        #createPlaylistButton:active {
            background-color: #00b359;
        }
        
        .playlist-item {
            display: flex;
            align-items: center;
            padding: var(--spacing-sm);
            background-color: var(--bg-card);
            border-radius: var(--border-radius-sm);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .playlist-item:hover {
            background-color: #222;
        }
        .playlist-item.active-playlist {
            border-left: 3px solid var(--secondary-accent);
        }

        .playlist-info {
            flex-grow: 1;
            padding-left: var(--spacing-md);
        }
        .playlist-info strong {
            display: block;
            font-size: 1rem;
            font-weight: 600;
        }
        .playlist-info span {
            font-size: 0.8rem;
            color: var(--text-low);
        }
        .playlist-icon {
            width: 28px;
            height: 28px;
            fill: var(--text-high);
            flex-shrink: 0;
        }
        .playlist-controls button {
             background: none;
             border: none;
             cursor: pointer;
             margin-left: var(--spacing-sm);
             padding: 5px;
        }
        .playlist-controls svg {
            width: 18px;
            height: 18px;
            fill: var(--text-low);
            transition: fill 0.2s;
        }
        .playlist-controls button:hover svg {
            fill: var(--secondary-accent);
        }
        
        /* NEW: Song Context Menu (Add to Playlist) - Kept as custom pop-up */
        .context-menu {
            position: fixed;
            background-color: var(--bg-card);
            border-radius: var(--border-radius-sm);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 40;
            min-width: 180px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            padding: var(--spacing-sm);
        }
        .context-menu-item {
            padding: var(--spacing-sm);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.1s;
            border-radius: var(--border-radius-sm);
            color: var(--text-high);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .context-menu-item:hover {
            background-color: #222;
        }
        .context-menu-item-heading {
             font-weight: 700;
             color: var(--primary-accent);
             padding: var(--spacing-sm) 0;
             border-bottom: 1px solid #333;
             margin-bottom: var(--spacing-xs);
        }


        /* --- PLAYER BAR (Fixed Footer) --- */
        .player-bar-container {
            position: fixed; 
            bottom: 60px; 
            left: 0;
            right: 0;
            padding: var(--spacing-sm) var(--spacing-md);
            background-color: var(--bg-card);
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.7);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            /* New: Transition for smooth hide/show */
            transition: transform 0.3s ease-out;
            transform: translateY(0); /* Default: visible */
        }
        
        /* New: Class to hide the player bar (approx 145px height) */
        .player-bar-container.minimized {
            /* Move it down by its own approximate height to hide it above the nav bar */
            /* The actual height is about 145px based on original height calculation */
            transform: translateY(145px); 
            box-shadow: none;
        }

        /* NEW: Style for the toggle button */
        #togglePlayerButton {
            position: absolute; 
            top: -15px; /* Position it slightly above the player bar */
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 25;
            padding: 2px 10px; /* Small pill shape */
            border-radius: 20px;
            background-color: var(--bg-card);
            border: 1px solid var(--text-low);
            cursor: pointer;
            line-height: 1;
            transition: background-color 0.2s;
        }
        #togglePlayerButton:active {
            background-color: #222;
        }
        #togglePlayerButton svg {
             width: 16px;
             height: 16px;
             fill: var(--primary-accent);
        }

        /* Player Info Row */
        .player-info-row {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }
        #playerAlbumArt {
            width: 55px;
            height: 55px;
            border-radius: var(--border-radius-sm);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
        }
        .player-controls-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-left: auto;
        }
        .control-button {
            background: none;
            border: none;
            cursor: pointer;
            line-height: 0;
            padding: var(--spacing-xs);
        }
        .control-button svg {
            width: 28px;
            height: 28px;
            fill: var(--primary-accent);
            transition: fill 0.2s, transform 0.1s;
        }
        .control-button:active svg {
            transform: scale(0.9);
        }
        #playPauseButton svg {
             width: 38px;
             height: 38px;
        }

        /* Utility/Shuffle/Repeat Icons */
        .utility-icon {
            width: 20px;
            height: 20px;
            fill: var(--text-low);
            transition: fill 0.2s;
        }
        .utility-icon.active {
            fill: var(--primary-accent);
        }

        /* Seek and Time Display */
        .seek-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        .time-display {
            font-size: 0.7rem;
            color: var(--text-low);
            width: 30px; 
            text-align: center;
        }
        #seekSlider {
            -webkit-appearance: none;
            appearance: none;
            flex-grow: 1;
            height: 4px;
            background: #444;
            border-radius: 5px;
            outline: none;
        }
        #seekSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--secondary-accent);
            cursor: pointer;
        }
        
        /* Volume Slider (Hidden on small mobile screens to save space) */
        .volume-control-group {
            display: none;
        }
        @media (min-width: 600px) {
            .volume-control-group {
                display: flex;
                align-items: center;
                gap: var(--spacing-sm);
                margin-left: var(--spacing-md);
            }
            #volumeSlider {
                 width: 80px;
            }
        }

        /* --- RECENT SEARCHES LIST (New Feature) --- */
        .recent-searches-container {
            padding: var(--spacing-md) 0;
            /* Hide by default until content is loaded */
            display: none; 
        }
        .search-term-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
            background-color: var(--bg-card);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-term-item:hover {
            background-color: #222;
        }
        .search-term-item span {
            font-size: 0.9rem;
            color: var(--text-high);
            font-weight: 400;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .search-term-item svg {
            width: 18px;
            height: 18px;
            fill: var(--text-low);
            margin-left: var(--spacing-md);
            flex-shrink: 0;
        }
        
        /* --- NEW: Android Style Modal/Dialog --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Dark semi-transparent background */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Highest Z-index */
            padding: 20px;
        }

        .modal-overlay.visible .modal-dialog {
            transform: scale(1);
            opacity: 1;
        }

        .modal-dialog {
            background-color: var(--bg-card);
            border-radius: var(--border-radius-lg);
            width: 100%;
            max-width: 300px; /* Typical Android dialog width */
            padding: var(--spacing-md);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.8);
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.2s ease-out;
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-high);
            margin-bottom: var(--spacing-sm);
        }

        .modal-message {
            font-size: 0.9rem;
            color: var(--text-low);
            margin-bottom: var(--spacing-lg);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right (standard Android practice) */
            gap: var(--spacing-sm);
        }

        .modal-button {
            padding: 8px 15px;
            border: none;
            border-radius: var(--border-radius-sm);
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.85rem;
            transition: background-color 0.1s;
        }

        .primary-button {
            background-color: var(--primary-accent);
            color: var(--bg-deep);
        }

        .secondary-button {
            background: none;
            color: var(--primary-accent);
        }
        /* --- END NEW MODAL CSS --- */
    </style>
</head>
<body>
    
    <div id="appTitle">
        <span class="char" style="--char-index: 0;">S</span>
        <span class="char" style="--char-index: 1;">o</span>
        <span class="char" style="--char-index: 2;">n</span>
        <span class="char" style="--char-index: 3;">g</span>
    </div>

    <div class="main-container">
        
        <div id="home-section" class="content-section active">
            <h2 class="heading-module" style="border-color: var(--primary-accent);">Discover Music</h2>
            <p class="loading-state" id="homeLoading">Loading categories...</p>

            <h2 class="heading-module" id="hindi-title">Hindi</h2>
            <div id="hindi-grid" class="module-grid"></div>

            <h2 class="heading-module" id="english-title">English</h2>
            <div id="english-grid" class="module-grid"></div>
                
            <h2 class="heading-module" id="bhojpuri-title">Bhojpuri</h2>
            <div id="bhojpuri-grid" class="module-grid"></div>
        </div>
        
        <div id="search-section" class="content-section">
            
            <div class="search-container-top">
                <input type="text" id="searchInput" placeholder="Search song, album, artist..." onkeypress="handleKeyPress(event)">
                
                <button class="search-button" onclick="searchSaavn()">
                    <svg viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L19.71,19L18.29,20.41L12.97,15.14C11.85,15.77 10.55,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5A4.5,4.5 0 0,0 5,9.5A4.5,4.5 0 0,0 9.5,14A4.5,4.5 0 0,0 14,9.5A4.5,4.5 0 0,0 9.5,5Z" /></svg>
                </button>
            </div>
            
            <div class="search-tab-container">
                <button class="search-tab active" data-endpoint="api/search/songs" onclick="setSearchEndpoint(this)">Songs</button>
                <button class="search-tab" data-endpoint="api/search/albums" onclick="setSearchEndpoint(this)">Albums</button>
                <button class="search-tab" data-endpoint="api/search/artists" onclick="setSearchEndpoint(this)">Artists</button>
                <button class="search-tab" data-endpoint="api/search/playlists" onclick="setSearchEndpoint(this)">Playlists</button>
            </div>
            
            <div class="recent-searches-container" id="recentSearchesContainer">
                <h3 class="sub-heading-module" style="margin-top: 0;">Recent Searches</h3>
                <div id="recentSearchesList" class="track-list">
                    </div>
            </div>
            <h2 class="heading-module" style="border-color: var(--secondary-accent);">Search Results</h2>
            <div id="songResults" class="track-list">
                <p class="loading-state">Type above to start searching.</p>
            </div>
        </div>

        <div id="queue-section" class="content-section">
            <h2 class="heading-module" style="border-color: var(--secondary-accent);">Current Queue / Up Next</h2>
            <div id="queueList" class="track-list" data-list-name="queue" data-allow-drag="true">
                <p class="loading-state">No songs in the queue.</p>
            </div>
        </div>
        
        <div id="playlists-section" class="content-section">
            <h2 class="heading-module" style="border-color: var(--primary-accent);">My Playlists</h2>

            <button id="createPlaylistButton" onclick="createPlaylist()">
                <svg style="width:18px;height:18px;vertical-align:middle;margin-right:8px;" viewBox="0 0 24 24"><path fill="currentColor" d="M17,14H19V17H22V19H19V22H17V19H14V17H17V14M17,10V7H7V10H5V7C5,5.89 5.9,5 7,5H17C18.11,5 19,5.89 19,7V10H17M5,12V21H12C11.94,20.67 11.9,20.34 11.89,20C11.89,17.43 12.8,15.15 14.33,13.59L13.88,13.14L13,14V19H11V16H6V19H7V21H5C3.89,21 3,20.11 3,19V12H5Z" /></svg>
                Create New Playlist
            </button>
            
            <h3 class="sub-heading-module">Your Collections</h3>
            <div id="userPlaylistsList">
                <div class="playlist-item active-playlist" data-playlist-id="favorites" data-playlist-name="Favorites" onclick="viewPlaylist('favorites')">
                    <svg class="playlist-icon" viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></svg>
                    <div class="playlist-info">
                        <strong>Favorites</strong>
                        <span id="favoritesCount">0 songs</span>
                    </div>
                    <div class="playlist-controls">
                        <button onclick="event.stopPropagation(); playPlaylist('favorites')" title="Play Playlist">
                            <svg viewBox="0 0 24 24"><path d="M8 5.14V19.14L19 12.14L8 5.14Z" /></svg>
                        </button>
                    </div>
                </div>
                </div>
            
            <h3 class="sub-heading-module" id="currentPlaylistTitle" style="display:none;">Playlist Tracks</h3>
            <div id="currentPlaylistTracks" class="track-list" data-list-name="custom_playlist" data-allow-drag="true">
                <p class="loading-state">Select a playlist to view songs.</p>
            </div>

        </div>
        </div>

    <div class="player-bar-container">
        
        <button id="togglePlayerButton" onclick="togglePlayerBar()" title="Collapse/Expand Player">
            <svg id="collapseIcon" viewBox="0 0 24 24"><path d="M7 14L12 9L17 14H7Z" /></svg>
            <svg id="expandIcon" viewBox="0 0 24 24" style="display: none;"><path d="M7 10L12 15L17 10H7Z" /></svg>
        </button>

        <div class="player-info-row">
            <img id="playerAlbumArt" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="Album Art" style="background-color: #333;">
            
            <div class="player-info">
                <div id="nowPlayingName" style="font-weight: 700;">No song is playing.</div>
                <div id="nowPlayingArtist" style="font-size: 0.8em; color: var(--text-low);"></div>
            </div>
            
            <div class="player-controls-group">
                <button id="shuffleButton" class="control-button" onclick="toggleShuffle()" title="Shuffle">
                    <svg class="utility-icon" id="shuffleIcon" viewBox="0 0 24 24"><path d="M14 4H18V8H14V4M14 14H18V18H14V14M10 18V15.4L4.85 10.25L6.27 8.83L11.5 14.06V11.23L16.25 6.47L17.66 7.88L11.5 14.06L16.73 19.3L15.31 20.72L10 15.49V18Z" /></svg>
                </button>
                
                <button id="repeatButton" class="control-button" onclick="toggleRepeat()" title="Repeat">
                    <svg class="utility-icon" id="repeatIcon" viewBox="0 0 24 24"><path d="M17 17.5V14.5L20.5 18L17 21.5V18.5H15A4 4 0 0 1 11 14.5V10.5H13V14.5A2 2 0 0 0 15 16.5H17Z M7 6.5V9.5L3.5 6L7 2.5V5.5H9A4 4 0 0 1 13 9.5V13.5H11V9.5A2 2 0 0 0 9 7.5H7Z" /></svg>
                </button>

                <div class="volume-control-group">
                    <svg class="utility-icon" viewBox="0 0 24 24"><path d="M14 3.23V5.29C16.89 6.15 19 8.83 19 12C19 15.17 16.89 17.85 14 18.71V20.77C18 19.86 21 16.29 21 12C21 7.71 18 4.14 14 3.23M16.5 12C16.5 10.23 15.5 8.71 14 7.97V16.03C15.5 15.29 16.5 13.77 16.5 12M3 9V15H7L12 20V4L7 9H3Z" /></svg>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7" style="height: 2px;">
                </div>
            </div>
        </div>

        <div class="seek-container">
            <span id="currentTime" class="time-display">0:00</span>
            <input type="range" id="seekSlider" min="0" max="100" value="0">
            <span id="totalDuration" class="time-display">0:00</span>
        </div>
        
        <div style="display: flex; justify-content: center; margin: var(--spacing-xs) 0;">
             <button id="prevButton" class="control-button" onclick="playPrev()" title="Previous">
                <svg viewBox="0 0 24 24" style="width:24px;height:24px;"><path d="M6 6H8V18H6V6M9.5 12L18 18V6L9.5 12Z" /></svg>
            </button>
            <button id="playPauseButton" class="control-button" onclick="togglePlayPause()" title="Play/Pause">
                <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5.14V19.14L19 12.14L8 5.14Z" /></svg>
                <svg id="pauseIcon" style="display:none;" viewBox="0 0 24 24"><path d="M14 19H18V5H14M6 19H10V5H6V19Z" /></svg>
            </button>
            <button id="nextButton" class="control-button" onclick="playNext()" title="Next">
                <svg viewBox="0 0 24 24" style="width:24px;height:24px;"><path d="M16 18H18V6H16V18M6 6V18L14.5 12L6 6Z" /></svg>
            </button>
        </div>

        <audio id="audioPlayer"></audio>
    </div>
    
    <div class="navigation">
        <div class="nav-item active" data-target="home-section" onclick="changeSection(this)">
            <svg viewBox="0 0 24 24"><path d="M10 20V14H14V20H19V12H22L12 3L2 12H5V20H10Z" /></svg>
            Home
        </div>
        <div class="nav-item" data-target="search-section" onclick="changeSection(this)">
            <svg viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L19.71,19L18.29,20.41L12.97,15.14C11.85,15.77 10.55,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5A4.5,4.5 0 0,0 5,9.5A4.5,4.5 0 0,0 9.5,14A4.5,4.5 0 0,0 14,9.5A4.5,4.5 0 0,0 9.5,5Z" /></svg>
            Search
        </div>
        
        <div class="nav-item" data-target="playlists-section" onclick="changeSection(this, true)">
             <svg viewBox="0 0 24 24"><path d="M10,21V3H5V21H10M19,21V8H14V21H19M22,21H20V6H13V21H11V1H22V21Z" /></svg>
            Playlists
        </div>
        <div class="nav-item" data-target="queue-section" onclick="changeSection(this)">
            <svg viewBox="0 0 24 24"><path d="M10,21H14V17H10V21M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M12,19A7,7 0 0,1 5,12A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19Z" /></svg>
            Queue
        </div>
    </div>
    
    <div id="contextMenu" class="context-menu" onmouseleave="this.style.display='none'">
        <div class="context-menu-item-heading">Add to Playlist</div>
        <div id="contextMenuPlaylists">
            </div>
    </div>
    
    <div id="appModal" class="modal-overlay">
        <div class="modal-dialog">
            <h3 id="modalTitle" class="modal-title"></h3>
            <p id="modalMessage" class="modal-message"></p>
            <div class="modal-actions">
                <button id="modalCancelButton" class="modal-button secondary-button" style="display: none;">Cancel</button>
                <button id="modalConfirmButton" class="modal-button primary-button">OK</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_BASE_URL = 'https://song1-beta.vercel.app/'; 
        
        const CATEGORY_CONFIG = [
            { id: 'hindi-grid', title: 'Hindi', query: 'Latest Hindi Songs', primary: true, endpoint: 'api/search/songs' }, 
            { id: 'english-grid', title: 'English', query: 'Hollywood Top Hits', endpoint: 'api/search/songs' }, 
            { id: 'bhojpuri-grid', title: 'Bhojpuri', query: 'Bhojpuri Song', endpoint: 'api/search/songs' }
        ];

        // --- DOM Elements ---
        const audioPlayer = document.getElementById('audioPlayer');
        const songResultsDiv = document.getElementById('songResults');
        const queueListDiv = document.getElementById('queueList');
        const nowPlayingName = document.getElementById('nowPlayingName');
        const nowPlayingArtist = document.getElementById('nowPlayingArtist');
        const playerAlbumArt = document.getElementById('playerAlbumArt');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const seekSlider = document.getElementById('seekSlider');
        const currentTimeDisplay = document.getElementById('currentTime');
        const totalDurationDisplay = document.getElementById('totalDuration');
        const shuffleIcon = document.getElementById('shuffleIcon');
        const repeatIcon = document.getElementById('repeatIcon');
        const favoritesCountSpan = document.getElementById('favoritesCount');
        const contextMenu = document.getElementById('contextMenu');
        const contextMenuPlaylists = document.getElementById('contextMenuPlaylists');
        // NEW DOM Elements for Player Toggle
        const playerBarContainer = document.querySelector('.player-bar-container');
        const collapseIcon = document.getElementById('collapseIcon');
        const expandIcon = document.getElementById('expandIcon');

        // --- State Variables ---
        let currentPlaylist = []; // The list of tracks currently loaded in the player
        let originalPlaylist = []; // Non-shuffled version of currentPlaylist
        let currentTrackIndex = -1;
        let isPlaying = false;
        let isShuffleOn = false;
        let repeatMode = 'none'; // 'none', 'one', 'all'
        let currentSearchEndpoint = 'api/search/songs'; // Default search type (relative to API_BASE_URL)
        let isPlayerMinimized = false;
        
        // NEW: Playlist State
        let playlists = {}; // { 'favorites': { name: 'Favorites', tracks: [...] }, 'user_123': { name: 'My Mix', tracks: [...] } }
        let currentViewPlaylistId = 'favorites'; // ID of the playlist currently shown in the playlists-section track list
        let trackBeingAdded = null; // Temporary storage for track object when context menu is open
        
        // NEW: Recent Searches State
        let recentSearches = [];
        const MAX_RECENT_SEARCHES = 7;

        // --- NEW: Custom Modal Implementation (Replaces generic alert/confirm) ---
        /** Reusable function to show the custom Android-style modal */
        function showAppModal(title, message, isConfirmation = false) {
            return new Promise(resolve => {
                const modal = document.getElementById('appModal');
                const titleEl = document.getElementById('modalTitle');
                const messageEl = document.getElementById('modalMessage');
                const confirmBtn = document.getElementById('modalConfirmButton');
                const cancelBtn = document.getElementById('modalCancelButton');

                titleEl.textContent = title;
                messageEl.textContent = message;
                
                // Setup buttons based on confirmation type
                if (isConfirmation) {
                    cancelBtn.style.display = 'inline-block';
                    confirmBtn.textContent = 'Yes';
                    cancelBtn.textContent = 'Cancel';
                    
                    // Clone to remove old listeners and attach new ones (safer than removeEventListener)
                    const oldConfirm = confirmBtn;
                    const newConfirm = oldConfirm.cloneNode(true);
                    oldConfirm.parentNode.replaceChild(newConfirm, oldConfirm);
                    
                    const oldCancel = cancelBtn;
                    const newCancel = oldCancel.cloneNode(true);
                    oldCancel.parentNode.replaceChild(newCancel, oldCancel);

                    newConfirm.onclick = () => {
                        modal.classList.remove('visible');
                        setTimeout(() => { modal.style.display = 'none'; }, 200);
                        resolve(true);
                    };
                    newCancel.onclick = () => {
                        modal.classList.remove('visible');
                        setTimeout(() => { modal.style.display = 'none'; }, 200);
                        resolve(false);
                    };
                } else {
                    cancelBtn.style.display = 'none';
                    confirmBtn.textContent = 'OK';

                    // Clone to remove old listener
                    const oldConfirm = confirmBtn;
                    const newConfirm = oldConfirm.cloneNode(true);
                    oldConfirm.parentNode.replaceChild(newConfirm, oldConfirm);

                    newConfirm.onclick = () => {
                        modal.classList.remove('visible');
                        setTimeout(() => { modal.style.display = 'none'; }, 200);
                        resolve(true); // Always resolves true for simple alerts
                    };
                }

                // Show the modal
                modal.style.display = 'flex';
                setTimeout(() => { modal.classList.add('visible'); }, 10);
            });
        }
        // --- END NEW: Custom Modal Implementation ---


        // --- DATA MANAGEMENT (Playlists & Favorites) ---

        /** Loads all playlists (including 'favorites') from local storage */
        function loadPlaylists() {
            try {
                const storedPlaylists = localStorage.getItem('musicAppPlaylists');
                playlists = storedPlaylists ? JSON.parse(storedPlaylists) : {};
                // Initialize 'favorites' if it doesn't exist (it's a permanent one)
                if (!playlists.favorites) {
                    playlists.favorites = { id: 'favorites', name: 'Favorites', tracks: [] };
                }
            } catch (e) {
                console.error("Could not load playlists from localStorage:", e);
                playlists = { favorites: { id: 'favorites', name: 'Favorites', tracks: [] } };
            }
        }

        /** Saves all playlists to local storage */
        function savePlaylists() {
            try {
                localStorage.setItem('musicAppPlaylists', JSON.stringify(playlists));
            } catch (e) {
                console.error("Could not save playlists to localStorage:", e);
            }
        }

        /** Creates a new, empty playlist (MODIFIED to use showAppModal) */
        async function createPlaylist() {
            const playlistName = prompt('Enter new playlist name:');
            if (!playlistName || playlistName.trim() === '') {
                await showAppModal('Error', 'Playlist name cannot be empty.'); // Replaced alert
                return;
            }

            const trimmedName = playlistName.trim();
            // Check for duplicate name
            if (Object.values(playlists).some(p => p.name.toLowerCase() === trimmedName.toLowerCase())) {
                await showAppModal('Duplicate Playlist', `Playlist with name "${trimmedName}" already exists.`); // Replaced alert
                return;
            }

            const newId = 'user_' + Date.now();
            playlists[newId] = {
                id: newId,
                name: trimmedName,
                tracks: []
            };

            savePlaylists();
            renderPlaylists();
            await showAppModal('Success', `Playlist "${playlistName}" created.`); // Replaced alert
        }

        /** Deletes a user-created playlist (MODIFIED to use showAppModal) */
        async function deletePlaylist(id) {
            if (id === 'favorites') return;
            if (!playlists[id]) return;

            const result = await showAppModal('Confirm Deletion', `Are you sure you want to delete the playlist "${playlists[id].name}"?`, true); // Replaced confirm

            if (result) {
                delete playlists[id];
                savePlaylists();
                renderPlaylists();
                // If the deleted playlist was the one being viewed, switch to favorites
                if (currentViewPlaylistId === id) {
                    viewPlaylist('favorites');
                }
            }
        }

        /** Toggles a track's favorite status (add/remove from 'favorites' playlist) */
        function toggleFavorite(track) {
            const trackId = track.id;
            const favs = playlists.favorites.tracks;
            const index = favs.findIndex(fav => fav.id === trackId);

            if (index > -1) {
                // Remove from favorites
                favs.splice(index, 1);
            } else {
                // Add to favorites (ensure the track object has the minimum required properties)
                favs.unshift(track); // Add to the top for easy access
            }

            savePlaylists();
            
            // Re-render the track list if 'favorites' is the current view
            if (currentViewPlaylistId === 'favorites') {
                viewPlaylist('favorites');
            }
            
            // Update the state of all favorite buttons for this song
            updateFavoriteButtons(trackId);
            
            // Update count displayed in the main 'Favorites' playlist item
            favoritesCountSpan.textContent = `${playlists.favorites.tracks.length} songs`;
        }

        /** Adds a track to a specific playlist (used by context menu) (MODIFIED to use showAppModal) */
        async function addTrackToPlaylist(playlistId, track) {
            const playlist = playlists[playlistId];
            if (!playlist) return;

            // Prevent adding duplicates
            if (playlist.tracks.some(t => t.id === track.id)) {
                await showAppModal('Duplicate Song', `"${track.name || 'Song'}" is already in "${playlist.name}".`); // Replaced alert
                return;
            }

            // Add the track to the playlist.
            playlist.tracks.push(track);
            savePlaylists();
            await showAppModal('Success', `"${track.name || 'Song'}" added to "${playlist.name}".`); // Replaced alert

            // Re-render if the target playlist is the current view
            if (currentViewPlaylistId === playlistId) {
                viewPlaylist(playlistId);
            }

            // Update list rendering if the target is 'favorites' (only if the user used the dedicated button)
            if (playlistId === 'favorites') {
                updateFavoriteButtons(track.id);
            }
            
            // Re-render the main playlist list to update track counts
            renderPlaylists();
        }

        /** Removes a track from the currently viewed playlist (MODIFIED to use showAppModal) */
        async function removeTrackFromPlaylist(trackId) {
            const playlistId = currentViewPlaylistId;
            const playlist = playlists[playlistId];
            if (!playlist) return;

            const result = await showAppModal('Confirm Removal', "Are you sure you want to remove this song from the playlist?", true); // Replaced confirm
            
            if (result) {
                const index = playlist.tracks.findIndex(t => t.id === trackId);
                if (index > -1) {
                    playlist.tracks.splice(index, 1);
                    savePlaylists();
                    viewPlaylist(playlistId); // Re-render the current list
                }
            }
        }


        /** Renders the list of user-created playlists and favorites (MODIFIED to fix duplication bug) */
        function renderPlaylists() {
            const favoritesItem = document.querySelector('.playlist-item[data-playlist-id="favorites"]');
            if (!favoritesItem) return;
            
            // FIX START: Remove all existing user-created playlist items to prevent duplication
            const userPlaylistsListDiv = document.getElementById('userPlaylistsList');
            userPlaylistsListDiv.querySelectorAll('.playlist-item').forEach(item => {
                // Ensure we only remove dynamically added user playlists, not the fixed 'favorites' item
                if (item.getAttribute('data-playlist-id') !== 'favorites') {
                    item.remove();
                }
            });
            // FIX END

            let userPlaylistsHtml = '';
            let playlistIds = Object.keys(playlists).filter(id => id !== 'favorites');
            playlistIds.forEach(id => {
                const playlist = playlists[id];
                userPlaylistsHtml += `
                    <div class="playlist-item ${currentViewPlaylistId === id ? 'active-playlist' : ''}" data-playlist-id="${id}" data-playlist-name="${playlist.name}" onclick="viewPlaylist('${id}')">
                        <svg class="playlist-icon" viewBox="0 0 24 24"><path d="M10,21V3H5V21H10M19,21V8H14V21H19M22,21H20V6H13V21H11V1H22V21Z" /></svg>
                        <div class="playlist-info">
                            <strong>${playlist.name}</strong>
                            <span>${playlist.tracks.length} songs</span>
                        </div>
                        <div class="playlist-controls">
                            <button onclick="event.stopPropagation(); playPlaylist('${id}')" title="Play Playlist">
                                <svg viewBox="0 0 24 24"><path d="M8 5.14V19.14L19 12.14L8 5.14Z" /></svg>
                            </button>
                            <button onclick="event.stopPropagation(); deletePlaylist('${id}')" title="Delete Playlist">
                                <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            // Inject the new content *after* the favorites item
            favoritesItem.classList.toggle('active-playlist', currentViewPlaylistId === 'favorites');
            favoritesCountSpan.textContent = `${playlists.favorites.tracks.length} songs`;
            favoritesItem.insertAdjacentHTML('afterend', userPlaylistsHtml);
        }

        /** Loads and displays the tracks of a selected playlist */
        function viewPlaylist(id) {
            const playlist = playlists[id];
            if (!playlist) return;

            // Update active state in the main list
            document.querySelectorAll('.playlist-item').forEach(item => { 
                item.classList.remove('active-playlist'); 
                if (item.getAttribute('data-playlist-id') === id) {
                    item.classList.add('active-playlist');
                }
            });
            
            // Update current view state
            currentViewPlaylistId = id;
            
            // Update tracks list title
            const titleEl = document.getElementById('currentPlaylistTitle');
            titleEl.textContent = `Tracks in: ${playlist.name}`;
            titleEl.style.display = 'block';

            // Check if the current list allows dragging (only custom playlists and queue do)
            const allowDrag = id !== 'favorites';
            document.getElementById('currentPlaylistTracks').setAttribute('data-allow-drag', allowDrag ? 'true' : 'false');
            
            // Render the tracks
            renderTrackList(playlist.tracks, document.getElementById('currentPlaylistTracks'), false, id);
            
            // Re-attach drag listeners (important for dynamic lists)
            attachDragListeners(document.getElementById('currentPlaylistTracks'));
        }
        
        // ... (The rest of the original JavaScript code, including utility functions, API calls, and event handlers, follows here, keeping all original functions like playTrack, playNext, playPlaylist, etc. intact except for the modifications above.)
        
        // --- Utility Functions --- 
        // ... (formatTime, changeSection, getArtistName, togglePlayerBar, updatePlayerUI, clearPlayerUI, togglePlayPause, playTrack, playNext, playPrev, toggleShuffle, toggleRepeat, setSearchEndpoint, searchSaavn, handleKeyPress, renderTrackList, updateFavoriteButtons, renderModuleGrid, fetchAndRenderCategory, initialLoad)
        
        // --- Utility Functions --- 

        /** Converts seconds to MM:SS format */ 
        function formatTime(seconds) { 
            if (isNaN(seconds) || seconds < 0) return "0:00"; 
            const min = Math.floor(seconds / 60); 
            const sec = Math.floor(seconds % 60); 
            return `${min}:${sec < 10 ? '0' : ''}${sec}`; 
        } 

        /** Changes the active content section */ 
        function changeSection(navItem, shouldRenderPlaylists = false) { 
            const targetId = navItem.getAttribute('data-target'); 
            // Remove active class from all sections 
            document.querySelectorAll('.content-section').forEach(section => { 
                section.classList.remove('active'); 
            }); 
            // Add active class to the target section 
            document.getElementById(targetId).classList.add('active'); 
            // Update navigation active state 
            document.querySelectorAll('.nav-item').forEach(item => { 
                item.classList.remove('active'); 
            }); 
            navItem.classList.add('active'); 
            // NEW: If switching to playlists, render the list and the default view 
            if (shouldRenderPlaylists || targetId === 'playlists-section') { 
                renderPlaylists(); 
                viewPlaylist(currentViewPlaylistId); 
            } 
            // Close context menu 
            contextMenu.style.display = 'none'; 
        } 

        /** Safely Get Artist Name from different possible fields */ 
        function getArtistName(track) { 
            // Priority: 1. primaryArtists (common in Saavn results) 
            if (track.primaryArtists) { 
                return track.primaryArtists; 
            } 
            // Priority: 2. artist (common in album tracks/legacy structure) 
            if (track.artist) { 
                return track.artist; 
            } 
            // Priority: 3. Nested artists structure 
            if (track.artists && track.artists.primary && track.artists.primary.length > 0) { 
                return track.artists.primary.map(a => a.name).join(', '); 
            } 
            // Fallback 
            return 'Unknown Artist'; 
        } 

        // --- Player Controls and UI Updates --- 

        /** Toggles the visibility of the player bar */ 
        function togglePlayerBar() { 
            isPlayerMinimized = !isPlayerMinimized; 
            if (isPlayerMinimized) { 
                playerBarContainer.classList.add('minimized'); 
                document.body.classList.add('player-minimized'); 
                collapseIcon.style.display = 'none'; 
                expandIcon.style.display = 'inline'; 
            } else { 
                playerBarContainer.classList.remove('minimized'); 
                document.body.classList.remove('player-minimized'); 
                collapseIcon.style.display = 'inline'; 
                expandIcon.style.display = 'none'; 
            } 
        } 

        /** Updates the Now Playing information in the player bar */ 
        function updatePlayerUI(track) { 
            if (track) { 
                nowPlayingName.textContent = track.name || 'Unknown Song'; 
                nowPlayingArtist.textContent = getArtistName(track); 
                playerAlbumArt.src = track.image ? track.image[track.image.length - 1].url : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                playerAlbumArt.alt = track.name; 
            } else { 
                clearPlayerUI(); 
            } 
            // Update 'is-playing' class on all track lists 
            document.querySelectorAll('.track-list').forEach(list => { 
                list.querySelectorAll('.track-item').forEach(item => { 
                    item.classList.remove('is-playing'); 
                    if (track && item.dataset.id === track.id && list.getAttribute('data-list-name') === 'queue') { 
                        item.classList.add('is-playing'); 
                        // Scroll the queue list to the playing song if it's the current view
                        if (document.getElementById('queue-section').classList.contains('active')) {
                            item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    } 
                }); 
            }); 
            // Update the play/pause button state 
            if (isPlaying) { 
                playIcon.style.display = 'none'; 
                pauseIcon.style.display = 'inline'; 
            } else { 
                playIcon.style.display = 'inline'; 
                pauseIcon.style.display = 'none'; 
            } 
        } 

        /** Clears the player bar UI */ 
        function clearPlayerUI() { 
            nowPlayingName.textContent = 'No song is playing.'; 
            nowPlayingArtist.textContent = ''; 
            playerAlbumArt.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
            playerAlbumArt.alt = 'Album Art'; 
            totalDurationDisplay.textContent = '0:00'; 
            currentTimeDisplay.textContent = '0:00'; 
            seekSlider.value = 0; 
        } 

        /** Toggles the play/pause state */ 
        function togglePlayPause() { 
            if (currentTrackIndex === -1 && currentPlaylist.length > 0) { 
                // If nothing is playing but we have a playlist, start the first song 
                playTrack(0); 
                return; 
            } 
            if (audioPlayer.paused) { 
                audioPlayer.play(); 
                isPlaying = true; 
                playIcon.style.display = 'none'; 
                pauseIcon.style.display = 'inline'; 
            } else { 
                audioPlayer.pause(); 
                isPlaying = false; 
                playIcon.style.display = 'inline'; 
                pauseIcon.style.display = 'none'; 
            } 
        } 

        /** Plays the track at the given index from the current playlist */ 
        function playTrack(index) { 
            if (index < 0 || index >= currentPlaylist.length) { 
                console.error("Invalid track index."); 
                return; 
            } 
            currentTrackIndex = index; 
            const track = currentPlaylist[currentTrackIndex]; 
            // Find the highest quality audio URL (usually the last in the list) 
            let audioUrl = track.downloadUrl ? track.downloadUrl[track.downloadUrl.length - 1].url : track.url; 
            
            // NEW: Add link to the server 
            if (audioUrl && !audioUrl.startsWith('http')) {
                 audioUrl = `${API_BASE_URL}api/song_link?url=${encodeURIComponent(audioUrl)}`;
            }

            if (!audioUrl) { 
                console.error("Audio URL not found for this track. Skipping."); 
                // If this is the only track, stop. 
                if (currentPlaylist.length === 1) { 
                    currentTrackIndex = -1; 
                    updatePlayerUI(null); 
                    return; 
                } 
                playNext(); 
                return; 
            } 

            // Update the player UI immediately 
            updatePlayerUI(track); 
            
            // Set and play the audio 
            audioPlayer.src = audioUrl; 
            audioPlayer.load(); 
            audioPlayer.play().then(() => { 
                isPlaying = true; 
                playIcon.style.display = 'none'; 
                pauseIcon.style.display = 'inline'; 
            }).catch(error => { 
                console.error("Audio play failed (CORS/Link issue):", error); 
                isPlaying = false; 
                playIcon.style.display = 'inline'; 
                pauseIcon.style.display = 'none'; 
            }); 
        } 

        /** Plays the next track */ 
        function playNext() { 
            if (currentPlaylist.length === 0) return; 

            if (repeatMode === 'one') { 
                playTrack(currentTrackIndex); // Replay current track 
                return; 
            } 

            let nextIndex = currentTrackIndex + 1; 
            if (nextIndex >= currentPlaylist.length) { 
                if (repeatMode === 'all') { 
                    nextIndex = 0; // Loop back to the start 
                } else { 
                    // Stop playing 
                    currentTrackIndex = -1; 
                    isPlaying = false; 
                    clearPlayerUI(); 
                    updatePlayerUI(null); 
                    return; 
                } 
            } 
            playTrack(nextIndex); 
        } 

        /** Plays the previous track */ 
        function playPrev() { 
            if (currentPlaylist.length === 0) return; 

            // If more than 3 seconds have passed, restart the current track 
            if (audioPlayer.currentTime > 3) { 
                playTrack(currentTrackIndex); 
                return; 
            } 

            let prevIndex = currentTrackIndex - 1; 
            if (prevIndex < 0) { 
                if (repeatMode === 'all') { 
                    prevIndex = currentPlaylist.length - 1; // Loop back to the end 
                } else { 
                    playTrack(currentTrackIndex); // Stay at the current track 
                    return; 
                } 
            } 
            playTrack(prevIndex); 
        } 


        /** Toggles shuffle state and reorders the currentPlaylist accordingly */ 
        function toggleShuffle() { 
            isShuffleOn = !isShuffleOn; 
            const shuffleIconElement = document.getElementById('shuffleIcon'); 

            if (isShuffleOn) { 
                shuffleIconElement.classList.add('active'); 
                // Store the current list, save its non-shuffled version 
                originalPlaylist = [...currentPlaylist]; 
                if (currentTrackIndex !== -1) { 
                    const currentTrack = currentPlaylist[currentTrackIndex]; 
                    let restOfList = currentPlaylist.filter((_, index) => index !== currentTrackIndex); 
                    // Simple Fisher-Yates shuffle on the rest of the list 
                    for (let i = restOfList.length - 1; i > 0; i--) { 
                        const j = Math.floor(Math.random() * (i + 1)); 
                        [restOfList[i], restOfList[j]] = [restOfList[j], restOfTist[i]]; 
                    } 
                    // Put the current song at the top of the new list 
                    currentPlaylist = [currentTrack, ...restOfList]; 
                    currentTrackIndex = 0; 
                } else { 
                    // Shuffle the whole list if nothing is playing 
                    for (let i = currentPlaylist.length - 1; i > 0; i--) { 
                        const j = Math.floor(Math.random() * (i + 1)); 
                        [currentPlaylist[i], currentPlaylist[j]] = [currentPlaylist[j], currentPlaylist[i]]; 
                    } 
                } 
            } else { 
                // Restore original list order 
                if (currentTrackIndex !== -1) { 
                    const currentTrack = currentPlaylist[currentTrackIndex]; 
                    currentPlaylist = [...originalPlaylist]; 
                    // Find the index of the currently playing song in the restored list 
                    currentTrackIndex = currentPlaylist.findIndex(track => track.id === currentTrack.id); 
                } else { 
                    currentPlaylist = [...originalPlaylist]; 
                } 
            } 
            renderQueue(); // Re-render the queue to show the new order 
        } 

        /** Toggles repeat mode */ 
        function toggleRepeat() { 
            if (repeatMode === 'none') { 
                repeatMode = 'all'; 
                repeatIcon.classList.add('active'); 
                repeatIcon.style.fill = 'var(--primary-accent)'; 
            } else if (repeatMode === 'all') { 
                repeatMode = 'one'; 
                repeatIcon.style.fill = 'var(--secondary-accent)'; 
            } else { 
                repeatMode = 'none'; 
                repeatIcon.classList.remove('active'); 
                repeatIcon.style.fill = 'var(--text-low)'; 
            } 
        } 

        /** Sets the active search endpoint */ 
        function setSearchEndpoint(tabElement) { 
            currentSearchEndpoint = tabElement.getAttribute('data-endpoint'); 
            document.querySelectorAll('.search-tab').forEach(tab => tab.classList.remove('active')); 
            tabElement.classList.add('active'); 
            songResultsDiv.innerHTML = `<p class="loading-state">Search mode changed to ${tabElement.textContent}. Type above to search.</p>`; 
            
            // Show/Hide recent searches based on tab 
            const isSongSearch = currentSearchEndpoint === 'api/search/songs'; 
            document.getElementById('recentSearchesContainer').style.display = isSongSearch && recentSearches.length > 0 ? 'block' : 'none'; 
        } 

        /** Performs the search using the current search input and endpoint */ 
        async function searchSaavn(queryFromRecent = null) { 
            const searchInput = document.getElementById('searchInput'); 
            const query = queryFromRecent || searchInput.value.trim(); 
            const searchType = currentSearchEndpoint.split('/').pop(); 

            if (!query) { 
                songResultsDiv.innerHTML = '<p class="loading-state">Please enter a search query.</p>'; 
                return; 
            } 
            
            // If the query came from recent searches, set the input value 
            if (queryFromRecent) { 
                searchInput.value = query; 
            } 

            songResultsDiv.innerHTML = `<p class="loading-state">Searching for "${query}"...</p>`; 

            try { 
                const url = `${API_BASE_URL}${currentSearchEndpoint}?query=${encodeURIComponent(query)}`; 
                const response = await fetch(url); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); 
                const data = await response.json(); 

                // Add search query to recent searches list 
                addSearchQuery(query); 
                
                // Original API structure often puts results inside 'data' -> 'results' 
                const results = data.data && data.data.results ? data.data.results : data.results || []; 

                // Conditional Rendering based on selected endpoint 
                if (searchType === 'songs') { 
                    // Search results are rendered as a track list, but drag/drop is disabled by the data-allow-drag attribute on the container 
                    renderTrackList(results, songResultsDiv, true); 
                } else { 
                    renderModuleGrid(results, songResultsDiv, currentSearchEndpoint); 
                } 
            } catch (error) { 
                console.error('Search failed (API/CORS issue likely):', error); 
                songResultsDiv.innerHTML = `<p class="loading-state" style="color: ${getComputedStyle(document.documentElement).getPropertyValue('--secondary-accent')}"> Error searching: Failed to fetch. (Check API URL or endpoint for ${searchType}) </p>`; 
            } 
        } 

        /** Handles Enter key press in search input */ 
        function handleKeyPress(event) { 
            if (event.key === 'Enter') { 
                searchSaavn(); 
            } 
        } 
        
        /** Renders a list of tracks to a specified container */ 
        function renderTrackList(tracks, container, isSearch = false, listId = 'queue_or_search') { 
            container.innerHTML = ''; // Clear previous results 
            container.classList.remove('module-grid'); 
            container.classList.add('track-list'); // Ensure correct styling 

            if (!tracks || tracks.length === 0) { 
                const message = isSearch ? 'No items found for your search.' : (listId === 'favorites' ? 'You haven\'t added any songs to favorites yet.' : (listId === 'queue_or_search' ? 'Queue is empty.' : 'No songs in this playlist.')); 
                container.innerHTML = `<p class="loading-state">${message}</p>`; 
                return; 
            } 

            // Function to handle track playback from a specific list 
            const handleTrackClick = (track, index, trackList) => { 
                currentPlaylist = trackList; 
                originalPlaylist = [...trackList]; 
                currentTrackIndex = index; 
                playTrack(index); 
                renderQueue(); // Automatically switch to Queue section on playing a new track (except when viewing a custom playlist/favorites) 
                if (listId === 'queue_or_search') { 
                    changeSection(document.querySelector('.nav-item[data-target="queue-section"]')); 
                } 
            }; 

            tracks.forEach((track, index) => { 
                const trackItem = document.createElement('div'); 
                // Determine if this track is the one currently playing and belongs to the queue 
                const isPlayingThisTrack = isPlaying && currentTrackIndex !== -1 && currentPlaylist[currentTrackIndex].id === track.id && listId === 'queue_or_search'; 

                trackItem.className = `track-item ${isPlayingThisTrack ? 'is-playing' : ''}`; 
                trackItem.dataset.id = track.id; // Store ID for drag/drop and playing logic 
                trackItem.dataset.index = index; // Store index for drag/drop 
                trackItem.draggable = false; // Drag is enabled separately by attachDragListeners 
                
                // Get track data as JSON string for inline functions 
                const trackJSON = JSON.stringify(track).replace(/"/g, '&quot;'); 

                // Click listener to play the song 
                trackItem.onclick = () => handleTrackClick(track, index, tracks); 

                // Build track controls 
                let trackControls = ''; 

                // 1. Drag Handle (only for non-search/non-favorites lists) 
                if (!isSearch && listId !== 'favorites') { 
                    trackControls += ` 
                        <div class="drag-handle"> 
                            <svg viewBox="0 0 24 24"><path d="M11 18H13V15H16V13H13V10H11V13H8V15H11V18M11 6H13V9H16V11H13V14H11V11H8V9H11V6Z" /></svg> 
                        </div>`; 
                } 

                // 2. Favorite Button (always shown for tracks) 
                trackControls += ` 
                    <button class="control-list-button ${playlists.favorites.tracks.some(fav => fav.id === track.id) ? 'is-favorite' : ''}" title="Add to Favorites" onclick="event.stopPropagation(); toggleFavorite(${trackJSON})"> 
                        <svg viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></svg> 
                    </button>`; 

                // 3. Add to Playlist Button (only for search results or queue) 
                if (isSearch || listId === 'queue_or_search') { 
                    trackControls += ` 
                        <button class="control-list-button" title="Add to Playlist" oncontextmenu="showContextMenu(event, ${trackJSON})" onclick="showContextMenu(event, ${trackJSON})"> 
                            <svg viewBox="0 0 24 24"><path d="M17,14H19V17H22V19H19V22H17V19H14V17H17V14M5,3H15A2,2 0 0,1 17,5V12.14L15,10.14V5H5V19H12.14L14.14,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3Z" /></svg> 
                        </button>`; 
                } 
                
                // 4. Remove from Playlist Button (only for custom playlist view) 
                if (!isSearch && listId !== 'favorites' && listId !== 'queue_or_search') { 
                    trackControls += ` 
                        <button class="control-list-button" title="Remove from Playlist" onclick="event.stopPropagation(); removeTrackFromPlaylist('${track.id}')"> 
                            <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg> 
                        </button>`; 
                } 

                trackItem.innerHTML = ` 
                    <img src="${track.image ? track.image[0].url : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" alt="${track.name || 'Song'}"> 
                    <div class="track-info"> 
                        <strong>${track.name || 'Unknown Song'}</strong> 
                        <span>${getArtistName(track)}</span> 
                    </div> 
                    <div style="margin-left: auto; display: flex; align-items: center;"> 
                        ${trackControls} 
                    </div> 
                `; 
                container.appendChild(trackItem); 
            }); 
            // Re-enable drag listeners on the new elements if allowed 
            if (container.getAttribute('data-allow-drag') === 'true') { 
                attachDragListeners(container); 
            } 
        } 
        
        /** Re-renders the Queue section */ 
        function renderQueue() { 
            // Use the listId 'queue_or_search' to ensure 'is-playing' class logic works correctly 
            renderTrackList(currentPlaylist, queueListDiv, false, 'queue_or_search'); 
            attachDragListeners(queueListDiv); 
        } 
        
        /** Plays a given album/playlist/artist tracks */ 
        async function playPlaylist(id, endpoint = 'api/playlists', type = 'playlist') { 
            // If playing the 'favorites' list from the dedicated button, use local list 
            if (id === 'favorites') { 
                if (playlists.favorites.tracks.length === 0) { 
                    await showAppModal('Playback Error', "Your Favorites list is empty. Add some songs first.");
                    return; 
                } 
                currentPlaylist = playlists.favorites.tracks; 
                originalPlaylist = [...currentPlaylist]; 
                renderQueue(); 
                changeSection(document.querySelector('.nav-item[data-target="queue-section"]')); 
                playTrack(0); 
                return; 
            } 

            queueListDiv.innerHTML = `<p class="loading-state">Loading tracks from ${type}...</p>`; 
            changeSection(document.querySelector('.nav-item[data-target="queue-section"]')); 

            try { 
                const url = `${API_BASE_URL}${endpoint}?id=${encodeURIComponent(id)}`; 
                const response = await fetch(url); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); 
                const data = await response.json(); 
                let tracks; 
                // Saavn API structure check: songs for albums/playlists, topSongs for artists 
                if (data.data && data.data.songs) { 
                    tracks = data.data.songs; 
                } else if (data.data && data.data.topSongs) { 
                    tracks = data.data.topSongs; 
                } else if (data.data && Array.isArray(data.data.results)) { 
                    tracks = data.data.results; 
                } else { 
                    tracks = []; 
                } 

                if (tracks.length > 0) { 
                    // Update main playlist and start playback 
                    currentPlaylist = tracks; 
                    originalPlaylist = [...tracks]; 
                    // Apply shuffle if it's on 
                    if (isShuffleOn) { 
                        toggleShuffle(); 
                    } 
                    renderQueue(); // Update queue UI with new tracks 
                    playTrack(0); // Start playing the first track 
                } else { 
                    queueListDiv.innerHTML = `<p class="loading-state">No songs found in this ${type}.</p>`; 
                } 
            } catch (error) { 
                console.error(`Failed to fetch tracks for ${type} ID ${id}:`, error); 
                queueListDiv.innerHTML = `<p class="loading-state" style="color: var(--secondary-accent)">Error loading tracks. (API or network issue)</p>`; 
            } 
        } 

        /** Renders a list of non-song items (album/artist/playlist) into a grid */ 
        function renderModuleGrid(items, container, typeEndpoint) { 
            container.innerHTML = ''; 
            container.classList.remove('track-list'); 
            container.classList.add('module-grid'); // Use grid style 

            if (!items || items.length === 0) { 
                 container.innerHTML = `<p class="loading-state">No items found.</p>`; 
                 return; 
            }

            items.forEach(item => { 
                // Extract relevant data 
                const id = item.id || item.perma_url; 
                const name = item.title || item.name; 
                const subtitle = item.subtitle || item.description || item.type; 
                const image = item.image ? item.image[item.image.length - 1].url : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                
                const type = typeEndpoint.split('/').pop().slice(0, -1); // 'albums' -> 'album' 

                const card = document.createElement('div'); 
                card.className = 'card-module'; 
                card.onclick = () => { 
                    playPlaylist(id, typeEndpoint, type); 
                }; 

                card.innerHTML = ` 
                    <img src="${image}" alt="${name}"> 
                    <strong>${name}</strong> 
                    <span>${subtitle}</span> 
                `; 
                container.appendChild(card); 
            }); 
        } 
        
        // --- Drag and Drop Logic (Remains unchanged) --- 
        let dragSrcEl = null;

        function handleDragStart(e) {
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            this.classList.add('dragging');
            
            // Prevent dragging if favorites list is the current view
            if (this.parentNode.getAttribute('data-list-name') === 'custom_playlist' && currentViewPlaylistId === 'favorites') {
                e.preventDefault();
                return false;
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
            
            // Highlight the drop target
            this.classList.remove('drag-over-above', 'drag-over-below');
            const rect = this.getBoundingClientRect();
            const y = e.clientY - rect.top;
            if (y < rect.height / 2) {
                this.classList.add('drag-over-above');
            } else {
                this.classList.add('drag-over-below');
            }
            return false;
        }

        function handleDragEnter(e) {
            // No need to do anything special here as dragOver handles highlighting
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over-above', 'drag-over-below');
        }

        function handleDrop(e) {
            e.stopPropagation(); 
            if (dragSrcEl === this) { 
                return false; 
            }
            
            this.classList.remove('drag-over-above', 'drag-over-below');

            if (dragSrcEl.parentNode !== this.parentNode) {
                // Dragging between different lists (not supported/needed for now)
                return false;
            }
            
            const dropContainer = this.parentNode;
            
            // Determine if drop is above or below
            const rect = this.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const dropAbove = y < rect.height / 2;

            // Get the list reference (currentPlaylist or a custom playlist's tracks)
            let tracksList;
            let listName = dropContainer.getAttribute('data-list-name');
            let listId = currentViewPlaylistId; // Only relevant for custom_playlist view

            if (listName === 'queue') {
                tracksList = currentPlaylist;
            } else if (listName === 'custom_playlist') {
                // Don't allow drag and drop reordering in the 'Favorites' view
                if (listId === 'favorites') return false; 
                tracksList = playlists[listId].tracks;
            } else {
                return false; // Safety check
            }
            
            // --- Reorder Logic ---
            const draggedTrackId = dragSrcEl.dataset.id;
            const targetTrackId = this.dataset.id;
            const draggedIndex = tracksList.findIndex(t => t.id === draggedTrackId);
            const targetIndex = tracksList.findIndex(t => t.id === targetTrackId);

            if (draggedIndex === -1 || targetIndex === -1) return false;

            // Remove the dragged track
            const [draggedTrack] = tracksList.splice(draggedIndex, 1);

            // Calculate new index
            let newIndex = targetIndex;
            if (!dropAbove) {
                newIndex++;
            } 
            
            // Insert the dragged track at the new position
            tracksList.splice(newIndex, 0, draggedTrack);

            // --- Update Player/UI State ---
            if (listName === 'queue') {
                // Update currentTrackIndex if the playing song was moved
                const currentlyPlayingTrack = currentPlaylist.length > 0 && currentTrackIndex !== -1 ? currentPlaylist[currentTrackIndex] : null;

                // Re-find the index of the current playing track if it was moved
                if (currentlyPlayingTrack) {
                    currentTrackIndex = currentPlaylist.findIndex(track => track.id === currentlyPlayingTrack.id);
                }
                
                // Save the new queue order to originalPlaylist if shuffle is off
                if (!isShuffleOn) {
                    originalPlaylist = [...currentPlaylist];
                }

                // Re-render the queue to update the UI
                renderQueue(); 

            } else if (listName === 'custom_playlist') {
                // Save the changes back to local storage
                savePlaylists();
                // Re-render the playlist view
                viewPlaylist(listId);
            }
            
            return true;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            dragSrcEl = null;
            
            // Remove highlighting from all items
            this.parentNode.querySelectorAll('.track-item').forEach(item => {
                item.classList.remove('drag-over-above', 'drag-over-below');
            });
        }

        /** Attaches drag-and-drop listeners to all track items in a container */
        function attachDragListeners(container) {
            if (container.getAttribute('data-allow-drag') !== 'true') return;
            container.querySelectorAll('.track-item').forEach(item => {
                // Remove existing listeners to prevent duplicates
                item.removeEventListener('dragstart', handleDragStart);
                item.removeEventListener('dragover', handleDragOver);
                item.removeEventListener('dragenter', handleDragEnter);
                item.removeEventListener('dragleave', handleDragLeave);
                item.removeEventListener('drop', handleDrop);
                item.removeEventListener('dragend', handleDragEnd);

                // Add new listeners
                item.setAttribute('draggable', true);
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragenter', handleDragEnter);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }
        
        // --- RECENT SEARCHES Management Functions (Remains unchanged) ---
        /** Loads recent searches from local storage */
        function loadRecentSearches() {
            try {
                const storedSearches = localStorage.getItem('musicAppRecentSearches');
                recentSearches = storedSearches ? JSON.parse(storedSearches) : [];
            } catch (e) {
                console.error("Could not load recent searches from localStorage:", e);
                recentSearches = [];
            }
        }

        /** Saves recent searches to local storage */
        function saveRecentSearches() {
            try {
                // Keep only the latest MAX_RECENT_SEARCHES
                localStorage.setItem('musicAppRecentSearches', JSON.stringify(recentSearches.slice(0, MAX_RECENT_SEARCHES)));
            } catch (e) {
                console.error("Could not save recent searches to localStorage:", e);
            }
        }

        /** Adds a query to the recent searches list, replacing if it exists */
        function addSearchQuery(query) {
            if (!query) return;
            const normalizedQuery = query.trim();
            
            // Remove the query if it already exists (to re-add it at the top)
            recentSearches = recentSearches.filter(q => q.toLowerCase() !== normalizedQuery.toLowerCase());

            // Add the new query to the beginning of the array
            recentSearches.unshift(normalizedQuery);
            
            // Trim the array to MAX_RECENT_SEARCHES
            recentSearches = recentSearches.slice(0, MAX_RECENT_SEARCHES);
            saveRecentSearches();
            renderRecentSearches();
        }

        /** Renders the current recent searches list */
        function renderRecentSearches() {
            const container = document.getElementById('recentSearchesList');
            const parentContainer = document.getElementById('recentSearchesContainer');
            container.innerHTML = ''; 

            if (recentSearches.length === 0) {
                parentContainer.style.display = 'none';
                return;
            }

            // Only show if the current search endpoint is for songs
            const isSongSearch = currentSearchEndpoint === 'api/search/songs';
            parentContainer.style.display = isSongSearch ? 'block' : 'none';

            recentSearches.forEach(query => {
                const item = document.createElement('div');
                item.className = 'search-term-item';
                item.onclick = () => searchSaavn(query); // Pass the query for search
                
                item.innerHTML = `
                    <span>${query}</span>
                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M13,3C8.03,3 4,7.03 4,12C4,16.97 8.03,21 13,21C14.77,21 16.42,20.5 17.88,19.64L13,12L17.88,4.36C16.42,3.5 14.77,3 13,3M19.8,4.2L21.4,5.8L17.5,12L21.4,18.2L19.8,19.8L13,12Z"/></svg>
                `; 
                container.appendChild(item);
            });
        }
        
        /** Toggles favorite status based on its ID across all current track lists */
        function updateFavoriteButtons(trackId) {
            const isFavorite = playlists.favorites.tracks.some(fav => fav.id === trackId);
            document.querySelectorAll(`.track-item[data-id="${trackId}"] .control-list-button[title="Add to Favorites"]`).forEach(button => {
                button.classList.toggle('is-favorite', isFavorite);
            });
            // Also update the count in the main playlist list (done in renderPlaylists/toggleFavorite)
        }

        /** Shows the "Add to Playlist" context menu */
        function showContextMenu(e, track) {
            e.preventDefault(); 
            e.stopPropagation();

            trackBeingAdded = track;
            contextMenuPlaylists.innerHTML = ''; // Clear previous items

            // Add all user-created playlists to the menu
            const playlistIds = Object.keys(playlists);
            playlistIds.forEach(id => {
                const playlist = playlists[id];
                // Don't show 'Favorites' as a separate menu item (user should use the heart button)
                if (id === 'favorites') return;

                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.textContent = playlist.name;
                item.onclick = (event) => {
                    event.stopPropagation();
                    addTrackToPlaylist(playlist.id, trackBeingAdded);
                    contextMenu.style.display = 'none';
                };
                contextMenuPlaylists.appendChild(item);
            });

            if (playlistIds.length === 1 && playlistIds[0] === 'favorites') {
                contextMenuPlaylists.innerHTML = `<div class="context-menu-item" style="color: var(--text-low); font-style: italic;">No custom playlists found.</div>`;
            }

            // Position and show the menu
            // Default position to bottom-right of the click/touch point
            let x = e.clientX || (e.touches && e.touches[0].clientX) || 0;
            let y = e.clientY || (e.touches && e.touches[0].clientY) || 0;

            // Adjust position to keep it on screen
            if (x + contextMenu.offsetWidth > window.innerWidth) {
                x = window.innerWidth - contextMenu.offsetWidth - 10;
            }
            if (y + contextMenu.offsetHeight > window.innerHeight) {
                y = window.innerHeight - contextMenu.offsetHeight - 10;
            }

            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';

            // Hide the menu if user clicks anywhere else on the screen
            document.onclick = () => {
                contextMenu.style.display = 'none';
                document.onclick = null; // Remove this handler after execution
            };

            // Prevent the document's click listener from immediately closing the menu
            contextMenu.onclick = (event) => {
                event.stopPropagation();
            }
        }
        
        /** Fetches search results for a category and renders them as a grid */
        async function fetchAndRenderCategory(config) {
            const container = document.getElementById(config.id);
            container.innerHTML = '<p class="loading-state">Loading...</p>';

            try {
                const url = `${API_BASE_URL}${config.endpoint}?query=${encodeURIComponent(config.query)}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                const results = data.data && data.data.results ? data.data.results.slice(0, 6) : [];

                container.innerHTML = ''; // Clear loading state
                container.classList.remove('track-list');
                container.classList.add('module-grid'); // Ensure grid style

                if (results.length === 0) {
                    container.innerHTML = '<p class="loading-state">No tracks found for this category.</p>';
                    return;
                }

                results.forEach(track => {
                    const card = document.createElement('div');
                    card.className = 'card-module';
                    // Pass track data to click handler
                    card.onclick = () => {
                        currentPlaylist = results;
                        originalPlaylist = [...results];
                        const clickedIndex = results.findIndex(t => t.id === track.id);
                        playTrack(clickedIndex);
                        renderQueue();
                        // Automatically switch to Queue section on playing a new track
                        changeSection(document.querySelector('.nav-item[data-target="queue-section"]'));
                    };

                    const name = track.name || track.title || 'Unknown';
                    const artist = getArtistName(track);
                    const image = track.image ? track.image[track.image.length - 1].url : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                    card.innerHTML = `
                        <img src="${image}" alt="${name}">
                        <strong>${name}</strong>
                        <span>${artist}</span>
                    `;
                    container.appendChild(card);
                });

            } catch (error) {
                console.error(`Error fetching ${config.title}:`, error);
                container.innerHTML = `<p class="loading-state" style="color: var(--secondary-accent)">Failed to load ${config.title}.</p>`;
            }
        }

        /** Initial load function */
        async function initialLoad() {
            // Load playlists first (includes favorites)
            loadPlaylists(); 
            // Load and render recent searches
            loadRecentSearches();
            renderRecentSearches();
            
            document.getElementById('homeLoading').style.display = 'block';

            await Promise.all(CATEGORY_CONFIG.map(config => fetchAndRenderCategory(config)));

            document.getElementById('homeLoading').style.display = 'none';

            CATEGORY_CONFIG.forEach(config => {
                const container = document.getElementById(config.id);
                const title = document.getElementById(`${config.id.split('-')[0]}-title`);
                if (title && container.children.length === 0) {
                    title.style.display = 'none';
                }
            });
            
            // Render playlist view on load (defaults to favorites)
            renderPlaylists();
            viewPlaylist(currentViewPlaylistId);
        }

        // --- Event Handlers for Audio Player --- 
        audioPlayer.addEventListener('timeupdate', () => { 
            const duration = audioPlayer.duration; 
            const currentTime = audioPlayer.currentTime; 
            if (isFinite(duration) && duration > 0) { 
                seekSlider.value = (currentTime / duration) * 100; 
                currentTimeDisplay.textContent = formatTime(currentTime); 
            } 
        }); 

        audioPlayer.addEventListener('loadedmetadata', () => { 
            if (isFinite(audioPlayer.duration)) { 
                totalDurationDisplay.textContent = formatTime(audioPlayer.duration); 
                seekSlider.max = 100; 
            } 
        }); 

        audioPlayer.addEventListener('ended', () => { 
            if (repeatMode === 'one') { 
                audioPlayer.currentTime = 0; 
                audioPlayer.play(); 
            } else { 
                playNext(); 
            } 
        }); 

        seekSlider.addEventListener('input', () => { 
            const seekTime = (seekSlider.value / 100) * audioPlayer.duration; 
            if (isFinite(seekTime)) { 
                audioPlayer.currentTime = seekTime; 
            } 
        }); 

        // Initialize the app
        initialLoad();
    </script>
</body>
</html>
